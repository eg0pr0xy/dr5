export interface MemoryEngineConfig {
  bufferSize?: number;
  grainDuration?: number;
  density?: number;
  ghostsActive?: boolean;
  pipsActive?: boolean;
  droneActive?: boolean;
}

export interface AudioEngineNodes {
  micStream: MediaStream | null;
  processor: ScriptProcessorNode | null;
  workletNode?: AudioWorkletNode | null;
  ringBuffer: AudioBuffer;
  ringData: Float32Array;
  bufferPtr: number;
  capturedSamples: number;
  mainGain: GainNode;
  droneFilter: BiquadFilterNode;
  droneGain: GainNode;
  staticGain: GainNode;
  dustGain: GainNode;
  grainsGain: GainNode;
  windowCurve: Float32Array;
  tiltLow: BiquadFilterNode;
  tiltHigh: BiquadFilterNode;
  scheduler: GrainScheduler;
}

export interface GrainScheduler {
  timer: number | null;
  lookahead: number;
  intervalMs: number;
  nextTime: number;
  grainDur: number;
  targetRate: number;
  ghostUntil: number;
  userDensity: number;
}

export interface MemoryDiagnostics {
  bufFill: number;
  grainRate: number;
  rms: number;
  lastGhost: string;
  currentStep: number;
  cutoff: number;
  q: number;
}

export interface KHSState {
  active: number;
  centroid: number;
  nextShift: number;
  momentId: number;
  fadePct: number;
  shapeF: number;
  shapeQ: number;
  spectralDensity: number[];
}

export interface MemoryModeProps {
  audioContext: AudioContext;
  isAnimated?: boolean;
}

export interface MemoryFragment {
  x: number;
  y: number;
  content: string;
  opacity: number;
  life: number;
  isVibrating: boolean;
}

export interface KHSModeProps {
  audioContext: AudioContext;
  isAnimated?: boolean;
}

export class KHSAudioEngine {
  private audioContext: AudioContext;
  private config: MemoryEngineConfig;
  private state: KHSState;
  
  // Audio nodes
  private oscillators: OscillatorNode[] = [];
  private gains: GainNode[] = [];
  private partials: { osc: OscillatorNode; gain: GainNode; baseFreq: number }[] = [];
  private spectralShapers: BiquadFilterNode[] = [];
  private mainGain: GainNode;
  
  // Radio streaming
  private radioElement: HTMLAudioElement | null = null;
  private radioGain: GainNode;
  private radioFilter: BiquadFilterNode;
  private radioAnalyser: AnalyserNode;
  private radioSource: MediaElementAudioSourceNode | null = null;
  
  // Static noise generators
  private staticNoise: { whiteGain: GainNode; pinkGain: GainNode; brownGain: GainNode };
  
  // Moment sequencing
  private momentTimer: number | null = null;
  private currentMoment: { id: number; startAt: number; nextAt: number; fadeDur: number; targetGains: number[]; driftFreqs: number[]; shapeFreqs: number[]; shapeQs: number[] };
  private activePermIndex: number = 0;
  
  // Diagnostics
  private ambientRms: number = 0;
  private micAnalyser: AnalyserNode;
  
  constructor(audioContext: AudioContext, config: MemoryEngineConfig = {}) {
    this.audioContext = audioContext;
    this.config = {
      initialFrequencies: [43.2, 86.4, 129.8, 172.6, 258.4, 344.8, 515.2, 86.4, 129.8, 172.6, 258.4, 344.8, 515.2, 86.4, 129.8, 172.6, 258.4, 344.8, 515.2, 86.4, 129.8, 172.6, 258.4, 344.8, 515.2, 86.4, 129.8, 172.6, 258.4, 344.8, 515.2, 86.4, 129.8, 172.6, 258.4, 344.8, 515.2, 86.4, 129.8, 172.6, 258.4, 344.8, 515.2, 86.4, 129.8, 172.6, 258.4],
      initialGains: new Array(14).fill(0.003),
      driftFactors: new Array(14).fill(0).map(() => (Math.random() - 0.5) * 0.02),
      ...config
    };
    
    this.state = {
      active: 0,
      centroid: 0,
      nextShift: 0,
      momentId: 0,
      fadePct: 0,
      shapeF: 0,
      shapeQ: 0,
      spectralDensity: new Array(14).fill(0)
    };
    
    this.initializeAudioNodes();
    this.setupRadioStreaming();
    this.startMomentSequencer();
  }
  
  private initializeAudioNodes(): void {
    // Main gain
    this.mainGain = this.audioContext.createGain();
    this.mainGain.gain.setValueAtTime(0.5, this.audioContext.currentTime);
    this.mainGain.connect(this.audioContext.destination);
    
    // Create 14 sine wave oscillators with detune
    for (let i = 0; i < 14; i++) {
      const osc = this.audioContext.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(this.config.initialFrequencies![i] || (43.2 * Math.pow(2, i)), this.audioContext.currentTime);
      const gain = this.audioContext.createGain();
      gain.gain.setValueAtTime(this.config.initialGains![i] || 0.003, this.audioContext.currentTime);
      osc.connect(gain);
      
      this.oscillators.push(osc);
      this.gains.push(gain);
      
      const partial = {
        osc,
        gain,
        baseFreq: this.config.initialFrequencies![i] || (43.2 * Math.pow(2, i))
      };
      this.partials.push(partial);
      
      // Add spectral shaper for each oscillator
      const shaper = this.audioContext.createBiquadFilter();
      shaper.type = 'allpass';
      shaper.frequency.setValueAtTime(1000, this.audioContext.currentTime);
      shaper.Q.setValueAtTime(8, this.audioContext.currentTime);
      shaper.connect(osc.frequency);
      osc.connect(shaper);
      
      this.spectralShapers.push(shaper);
    }
    
    // Static noise generators
    this.createStaticNoiseGenerators();
    
    // Microphone analyser
    this.micAnalyser = this.audioContext.createAnalyser();
    this.micAnalyser.fftSize = 512;
  }
  
  private createStaticNoiseGenerators(): void {
    const bufferSize = this.audioContext.sampleRate * 2;
    
    // White noise buffer
    const whiteBuffer = this.audioContext.createBuffer(1, bufferSize);
    const whiteData = whiteBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      whiteData[i] = Math.random() * 2 - 1;
    }
    
    // Pink noise buffer
    const pinkBuffer = this.audioContext.createBuffer(1, bufferSize);
    const pinkData = pinkBuffer.getChannelData(0);
    let lastOut = 0;
    for (let i = 0; i < bufferSize; i++) {
      const white = Math.random() * 2 - 1;
      pinkData[i] = (white + lastOut) * 0.047;
      lastOut = pinkData[i];
    }
    
    // Brown noise buffer
    const brownBuffer = this.audioContext.createBuffer(1, bufferSize);
    const brownData = brownBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      brownData[i] = (Math.random() * 2 - 1) * 0.067;
    }
    
    // Create buffer sources
    const whiteSource = this.audioContext.createBufferSource();
    whiteSource.buffer = whiteBuffer;
    const pinkSource = this.audioContext.createBufferSource();
    pinkSource.buffer = pinkBuffer;
    const brownSource = this.audioContext.createBufferSource();
    brownSource.buffer = brownBuffer;
    
    // Create gains and connect
    this.staticNoise.whiteGain = this.audioContext.createGain();
    this.staticNoise.whiteGain.gain.setValueAtTime(0.02, this.audioContext.currentTime);
    this.staticNoise.whiteGain.connect(this.mainGain);
    
    this.staticNoise.pinkGain = this.audioContext.createGain();
    this.staticNoise.pinkGain.gain.setValueAtTime(0.02, this.audioContext.currentTime);
    this.staticNoise.pinkGain.connect(this.mainGain);
    
    this.staticNoise.brownGain = this.audioContext.createGain();
    this.staticNoise.brownGain.connect(this.mainGain);
    
    whiteSource.connect(this.staticNoise.whiteGain);
    pinkSource.connect(this.staticNoise.pinkGain);
    brownSource.connect(this.staticNoise.brownGain);
    
    whiteSource.start();
    pinkSource.start();
    brownSource.start();
  }
  
  private setupRadioStreaming(): void {
    try {
      this.radioElement = new Audio("https://dradio-edge-209a-fra-lg-cdn.cast.addradio.de/dradio/dlf/live/mp3/128/stream.mp3");
      this.radioElement.crossOrigin = "anonymous";
      this.radioElement.loop = true;
      
      this.radioGain = this.audioContext.createGain();
      this.radioGain.gain.setValueAtTime(0.0, this.audioContext.currentTime);
      
      this.radioFilter = this.audioContext.createBiquadFilter();
      this.radioFilter.type = 'bandpass';
      this.radioFilter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
      this.radioFilter.Q.setValueAtTime(10, this.audioContext.currentTime);
      
      this.radioAnalyser = this.audioContext.createAnalyser();
      this.radioAnalyser.fftSize = 512;
      
      this.radioSource = this.audioContext.createMediaElementSource(this.radioElement);
      this.radioSource.connect(this.radioAnalyser);
      this.radioAnalyser.connect(this.radioFilter);
      this.radioGain.connect(this.radioGain);
      this.radioGain.connect(this.mainGain);
    } catch (error) {
      console.warn('Radio streaming not available:', error);
    }
  }
  
  private startMomentSequencer(): void {
    this.momentTimer = window.setInterval(() => {
      if (!this.oscillators.length) return;
      
      const now = this.audioContext.currentTime;
      
      // Check if current moment should transition
      if (now >= this.currentMoment.nextAt) {
        this.scheduleNewMoment(now);
      }
      
      // Update RMS from microphone
      if (this.micAnalyser) {
        const dataArray = new Uint8Array(this.micAnalyser.fftSize);
        this.micAnalyser.getByteTimeDomainData(dataArray);
        
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += (dataArray[i] - 128) * (dataArray[i] - 128);
        }
        
        this.ambientRms = Math.sqrt(sum / dataArray.length);
      }
      
      // Update spectral density based on RMS
      const targetDensity = Math.min(0.1, Math.max(0, this.ambientRms * 50));
      this.state.spectralDensity = this.state.spectralDensity.map((_, i) => 
        i === this.activePermIndex ? targetDensity : _
      );
    }, 100);
  }
  
  private scheduleNewMoment(now: number): void {
    const peaks = 1 + Math.floor(Math.random() * 3); // 1–3 peaks
    const fade = 30 + Math.random() * 60; // 30–90s fade
    const nextIn = now + fade + 60; // 60s buffer before next
    
    // Calculate target gains based on moment
    const targetGains = new Array(14).fill(0);
    const driftFreqs: number[] = [];
    const shapeFreqs: number[] = [];
    const shapeQs: number[] = [];
    
    for (let i = 0; i < 14; i++) {
      // Frequency drift
      const baseFreq = this.config.initialFrequencies![i] || (43.2 * Math.pow(2, i));
      const driftFactor = this.config.driftFactors![i] || 0);
      const driftFreq = baseFreq * (1 + driftFactor * (Math.random() - 0.5));
      driftFreqs.push(driftFreq);
      
      // Target gains with quiet base + shaped gain
      const baseGain = this.config.initialGains![i] || 0.003);
      let peakGain = 0;
      for (let p = 0; p < peaks; p++) {
        const sigma = 0.8 + Math.random() * 2.5;
        const d = (i - 7) / sigma;
        const gaussian = Math.exp(-0.5 * d * d);
        peakGain += gaussian;
      }
      
      const targetGain = baseGain * (0.1 + peakGain * 0.9);
      targetGains[i] = targetGain;
      
      // Spectral shaping based on moment
      const shapeFreq = baseFreq * (2 + Math.random() * 4);
      const shapeQ = 4 + Math.random() * 8;
      shapeFreqs.push(shapeFreq);
      shapeQs.push(shapeQ);
    }
    
    // Update moment
    this.currentMoment = {
      id: this.currentMoment.id + 1,
      startAt: now,
      nextAt: nextIn,
      fadeDur: fade,
      targetGains,
      driftFreqs,
      shapeFreqs,
      shapeQs
    };
    
    // Update active partial for rotation
    this.activePermIndex = (this.activePermIndex + 1) % 14;
  }
  
  private applyMoment(): void {
    const now = this.audioContext.currentTime;
    const moment = this.currentMoment;
    
    // Fade out current gains
    this.partials.forEach((partial, i) => {
      partial.gain.gain.cancelScheduledValues(now);
      partial.gain.gain.setValueAtTime(partial.gain.gain.value * 0.1, now);
      partial.gain.gain.linearRampToValueAtTime(moment.targetGains[i], now + moment.fadeDur);
    });
    
    // Fade in new gains
    this.partials.forEach((partial, i) => {
      partial.gain.gain.cancelScheduledValues(now);
      partial.gain.gain.setValueAtTime(moment.targetGains[i], now + moment.fadeDur);
      
      // Update frequency drift
      partial.osc.frequency.cancelScheduledValues(now);
      partial.osc.frequency.setValueAtTime(moment.driftFreqs[i], now + moment.fadeDur);
      
      // Update spectral shaper
      const shaper = this.spectralShapers[i];
      shaper.frequency.cancelScheduledValues(now);
      shaper.frequency.setValueAtTime(moment.shapeFreqs[i], now + moment.fadeDur);
      
      shaper.Q.cancelScheduledValues(now);
      shaper.Q.setValueAtTime(moment.shapeQs[i], now + moment.fadeDur);
    });
    
    // Update centroid calculation
    const totalWeight = moment.targetGains.reduce((sum, gain) => sum + gain, 0);
    const centroid = moment.targetGains.reduce((sum, gain, i) => sum + gain * (this.config.initialFrequencies![i] || (43.2 * Math.pow(2, i)), 0) / totalWeight);
    
    this.state.centroid = centroid;
    this.state.nextShift = Math.floor((centroid - 860) / 100); // Convert to 0-860 range
  }
  
  public start(): void {
    // Start all oscillators
    this.oscillators.forEach(osc => osc.start());
    
    // Start static noise
    this.mainGain.gain.setValueAtTime(0.5, this.audioContext.currentTime);
    
    // Start radio if available
    if (this.radioSource) {
      this.radioSource!.start();
    }
    
    // Start moment sequencer
    this.startMomentSequencer();
  }
  
  public stop(): void {
    // Stop all oscillators
    this.oscillators.forEach(osc => osc.stop());
    
    // Stop moment sequencer
    if (this.momentTimer) {
      clearInterval(this.momentTimer);
    }
    
    // Stop radio
    if (this.radioElement && !this.radioElement.paused) {
      this.radioElement.pause();
    }
  }
  
  public setDriftFactors(factors: number[]): void {
    this.config.driftFactors = factors;
  }
  
  public setSaturation(amount: number): void {
    // Apply saturation to all oscillators
    this.partials.forEach((partial, i) => {
      const waveshaper = this.audioContext.createWaveShaper();
      waveshaper.curve = this.makeSaturationCurve(amount);
      waveshaper.oversample = '4x';
      partial.osc.disconnect();
      partial.osc.connect(waveshaper);
      waveshaper.connect(partial.gain);
      waveshaper.connect(partial.gain);
      partial.gain.connect(this.spectralShapers[this.partials.indexOf(partial)]);
    });
  }
  
  public setRadioActive(active: boolean): void {
    if (!this.radioElement) return;
    
    try {
      if (active) {
        this.radioElement.play();
      } else {
        this.radioElement.pause();
      }
    } catch (error) {
      console.warn('Radio control failed:', error);
    }
  }
  
  public getState(): KHSState {
    return { ...this.state };
  }
  
  public dispose(): void {
    this.stop();
    
    // Clean up audio nodes
    this.oscillators.forEach(osc => {
      try { osc.stop(); osc.disconnect(); } catch {}
    });
    
    this.spectralShapers.forEach(shaper => {
      try { shaper.disconnect(); } catch {}
    });
    
    this.gains.forEach(gain => {
      try { gain.disconnect(); } catch {}
    });
    
    // Clean up radio
    if (this.radioSource) {
      try { this.radioSource.disconnect(); } catch {}
    }
    
    // Clean up static noise
    Object.values(this.staticNoise).forEach(gain => {
      try { gain.disconnect(); } catch {}
    });
    
    // Clean up main gain
    try { this.mainGain.disconnect(); } catch {}
    
    // Clear timer
    if (this.momentTimer) {
      clearInterval(this.momentTimer);
    }
  }
}

